
import os
import sys
import time
import requests
import json
from pathlib import Path

# Configuration
BASE_URL_PROVIDER = "http://localhost:8080"
BASE_URL_JUDGE = "http://localhost:8081"
BASE_URL_RESULTS = "http://localhost:8082"
WASM_PATH = Path("compiled-wasm/pii_detector.wasm")

def wait_for_service(url, service_name, timeout=60):
    print(f"Waiting for {service_name} at {url}...")
    start_time = time.time()
    while time.time() - start_time < timeout:
        try:
            response = requests.get(f"{url}/health")
            if response.status_code == 200:
                print(f"{service_name} is ready.")
                return True
        except requests.ConnectionError:
            pass
        time.sleep(1)
    print(f"Timed out waiting for {service_name}.")
    return False

def run_test():
    # 1. Health Checks
    if not wait_for_service(BASE_URL_PROVIDER, "Data Provider"):
        sys.exit(1)
    if not wait_for_service(BASE_URL_JUDGE, "Judge"):
        sys.exit(1)

    # 2. Check for WASM artifact
    if not WASM_PATH.exists():
        print(f"Error: WASM file not found at {WASM_PATH}. Please build it first.")
        # Try to find it in the project if path is slightly off relative to CWD
        project_root = Path(__file__).parent.parent
        alt_path = project_root / "compiled-wasm" / "pii_detector.wasm"
        if alt_path.exists():
            print(f"Found WASM at {alt_path}")
            wasm_to_use = alt_path
        else:
             sys.exit(1)
    else:
        wasm_to_use = WASM_PATH

    # 3. Submit Challenge
    print("\nSubmitting Challenge...")
    try:
        with open(wasm_to_use, 'rb') as f:
            files = {'wasm': ('pii_detector.wasm', f, 'application/wasm')}
            data = {'nonce': 'test_nonce_' + str(int(time.time()))}
            response = requests.post(f"{BASE_URL_PROVIDER}/challenge", files=files, data=data)
            
        if response.status_code != 200:
            print(f"Failed to submit challenge: {response.status_code} - {response.text}")
            sys.exit(1)
            
        result = response.json()
        if not result.get('success'):
            print(f"Challenge submission failed: {result.get('error')}")
            sys.exit(1)
            
        challenge_id = result.get('challenge_id')
        print(f"Challenge submitted successfully. ID: {challenge_id}")
        
    except Exception as e:
        print(f"Exception during submission: {e}")
        sys.exit(1)

    # 4. Verify Results (Active Polling)
    # The Judge processes it async (or sync depending on implementation, but let's assume valid latency)
    print(f"\nVerifying results for Challenge ID: {challenge_id}...")
    
    # We can check the Results Board static file or the Judge's index.json
    # Since Results Board is just nginx serving files generated by Judge, and Judge writes to a shared volume...
    # Let's try to fetch from the Results Board URL
    
    max_retries = 10
    found = False
    
    for i in range(max_retries):
        try:
            # Try to fetch the specific result JSON from the results board
            # URL structure depends on nginx config, usually results are at root
            res_url = f"{BASE_URL_RESULTS}/{challenge_id}.json"
            response = requests.get(res_url)
            
            if response.status_code == 200:
                print(f"Found result at {res_url}")
                result_data = response.json()
                print("Verdict:", result_data.get('verdict'))
                print("Attestation Valid:", result_data.get('attestation_valid'))
                found = True
                break
            else:
                print(f"Result not yet available (Status {response.status_code}). Retrying ({i+1}/{max_retries})...")
        except requests.ConnectionError:
            print("Connection error checking results board. Retrying...")
            
        time.sleep(2)
        
    if not found:
        print("Test FAILED: Result did not appear on Results Board within timeout.")
        sys.exit(1)
        
    print("\nTest PASSED! End-to-end flow verified.")

if __name__ == "__main__":
    run_test()
